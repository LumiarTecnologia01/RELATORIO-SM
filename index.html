<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solicitação de Materiais</title>
  <!-- Bootstrap CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
    crossorigin="anonymous"
  />
  <style>
    body { background: #f8fafc; }
    .page-header { border-bottom: 1px solid #e5e7eb; }
    .section-title { font-weight: 600; color: #334155; }
    .table thead th { background: #e9f0ff; color: #0f172a; }
    .top-actions { gap: .5rem; }
    .required::after { content: " *"; color: #dc3545; }

    /* Overlay de carregamento global */
    .loading-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5000; /* bem acima da modal/backdrop do Bootstrap */
    }
    .loading-card {
      background: #fff;
      border-radius: .5rem;
      box-shadow: 0 10px 30px rgba(0,0,0,.15);
      padding: 1.25rem 1.5rem;
      display: flex;
      gap: .75rem;
      align-items: center;
      min-width: 240px;
    }
    .loading-text { font-weight: 500; color: #0f172a; }

    /* Impressão */
    @media print {
      .no-print { display: none !important; }
      body { background: white; }
      .card { box-shadow: none; border: none; }
    }
  </style>
</head>
<body>
  <div class="container py-3">
    <div class="d-flex justify-content-between align-items-center page-header pb-2 mb-3">
      <h1 class="h4 m-0">Solicitação de Materiais</h1>
      <div class="top-actions d-flex no-print">
        <button id="btnToggleEdit" class="btn btn-primary">Editar todos</button>
        <button id="btnSalvar" class="btn btn-success">Salvar solicitação</button>
        <button id="btnImprimir" class="btn btn-outline-primary">Imprimir</button>
      </div>
    </div>

    <div id="appAlerts" class="no-print"></div>

    <div class="card mb-3">
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-6">
            <label for="solicitante" class="form-label required">Solicitante</label>
            <input type="text" id="solicitante" class="form-control" placeholder="Nome do solicitante" />
          </div>
          <div class="col-md-6">
            <label for="centroCusto" class="form-label required">Centro de custo</label>
            <select id="centroCusto" class="form-select">
              <option value="">Carregando...</option>
            </select>
          </div>
          <div class="col-12">
            <label for="narrativa" class="form-label">Narrativa</label>
            <textarea id="narrativa" class="form-control" rows="3" placeholder="Descreva a necessidade, observações etc."></textarea>
          </div>
        </div>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-header bg-white">
        <span class="section-title">Itens</span>
      </div>
      <div class="card-body">
        <div class="row g-3 align-items-end">
          <div class="col-md-6">
            <label class="form-label required">Produto</label>
            <div class="d-flex gap-2">
              <button id="btnAbrirModalProdutos" type="button" class="btn btn-outline-secondary flex-shrink-0">Selecionar produto(s)</button>
              <button id="btnCarregar" type="button" class="btn btn-outline-primary flex-shrink-0">Carregar</button>
              <select id="produto" class="form-select">
                <option value="">Carregando...</option>
              </select>
            </div>
          </div>
          <div class="col-md-3">
            <label for="quantidade" class="form-label required">Quantidade</label>
            <input type="number" min="1" step="1" id="quantidade" class="form-control" placeholder="0" />
          </div>
          <div class="col-md-3 d-flex gap-2 no-print">
            <button id="btnAdicionar" class="btn btn-success flex-fill">Adicionar</button>
            <button id="btnLimpar" class="btn btn-primary flex-fill" type="button">Limpar</button>
          </div>
        </div>
      </div>

      <div class="table-responsive">
        <table class="table align-middle mb-0">
          <thead>
            <tr>
              <th style="width:50%">Produto</th>
              <th style="width:20%">Quantidade</th>
              <th class="no-print" style="width:30%">Opções</th>
            </tr>
          </thead>
          <tbody id="tbodyItens"></tbody>
        </table>
      </div>
    </div>

    <footer class="text-muted small">
      <p class="mb-0">Preencha os campos obrigatórios e adicione os itens antes de salvar.</p>
    </footer>
  </div>

  <!-- Bootstrap JS (opcional para componentes como toasts/modals) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

  <!-- Overlay de Carregamento -->
  <div id="globalLoading" class="loading-backdrop d-none" aria-hidden="true">
    <div class="loading-card">
      <div class="spinner-border text-primary" role="status" aria-hidden="true"></div>
      <div class="loading-text" id="globalLoadingText">Carregando...</div>
    </div>
  </div>

  <!-- Modal Seleção de Produtos -->
  <div class="modal fade" id="modalProdutos" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Selecionar produtos</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="row g-2 mb-2 align-items-center">
            <div class="col-sm-6 col-md-4">
              <input id="produtoSearch" type="search" class="form-control" placeholder="Buscar por código ou nome" />
            </div>
            <div class="col-auto">
              <button id="btnCarregarProdutos" type="button" class="btn btn-outline-primary">Carregar todos</button>
            </div>
            <div id="lblModalProdutosInfo" class="col text-muted small d-flex align-items-center"></div>
          </div>
          <div class="table-responsive">
            <table class="table table-sm align-middle">
              <thead>
                <tr>
                  <th style="width:40px"></th>
                  <th style="width:120px">Código</th>
                  <th>Nome</th>
                  <th style="width:120px">Qtd</th>
                </tr>
              </thead>
              <tbody id="tbodyModalProdutos"></tbody>
            </table>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="button" id="btnAddSelecionados" class="btn btn-primary">Adicionar selecionados</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =====================
    // Configuração de APIs
    // =====================
    // Ajuste as URLs abaixo para apontar para suas APIs.
    // As APIs esperadas:
    // - GET centros de custo: retorna array de { id, nome }
    // - GET produtos: retorna array de { id, nome }
    // - POST salvar solicitação: recebe { solicitante, centroCustoId, narrativa, itens:[{produtoId, quantidade}] }
    const API = {
      produtosUrl: 'https://novaapi-lb2.vendaerp.com.br/v3/produtos/produtos',
      centrosCustoUrl: 'https://example.com/api/centros-custo',
      salvarSolicitacaoUrl: 'https://example.com/api/solicitacoes'
    };

    // Parâmetros opcionais por recurso (ex.: paginação/filtros exigidos pela API)
    const API_PARAMS = {
      produtos: {
        // Exemplo: page: 1, limit: 100, ativo: true
      }
    };

    // Configuração por recurso (método/corpo) — útil para APIs que exigem POST em listagens
    const API_REQUEST = {
      produtos: {
        method: 'POST', // API exige POST (GET resulta em 405)
        body: { Pagina: { Number: 0, Lenght: 100 } }
      }
    };

    // Helper para ler cookie com segurança (usado para obter o token em produção)
    function getCookie(name) {
      if (typeof document === 'undefined' || !name) return null;
      const pattern = new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\/\+^])/g, '\\$1') + '=([^;]*)');
      const match = document.cookie.match(pattern);
      return match ? decodeURIComponent(match[1]) : null;
    }

    // Helper para ler meta tag <meta name="..." content="...">
    function getMeta(name) {
      if (typeof document === 'undefined' || !name) return null;
      const el = document.querySelector(`meta[name="${name}"]`);
      return el ? el.getAttribute('content') : null;
    }

    // Token da API (cole aqui se a API exigir Authorization Bearer)
    // Ex.: const API_TOKEN = 'seu_token_aqui';
    const API_TOKEN = 'eca80d9f279a583d0714bb686fd0b4b5';
    //const API_TOKEN = (typeof window !== 'undefined' && (window.ERPUSETOKEN || window.ERPTOKEN))
      //|| getMeta('erpusertoken')
      //|| getCookie('erpusertoken')
      //|| (typeof localStorage !== 'undefined' ? localStorage.getItem('erpusertoken') : null)
      //|| (typeof sessionStorage !== 'undefined' ? sessionStorage.getItem('erpusertoken') : null)
      //|| 'token-nao-encontrado';

    // Configuração do header de autenticação
    // mode: 'bearer' | 'plain' | 'x-api-key' | 'none'
    // - bearer -> Authorization: Bearer <token>
    // - plain  -> Authorization: <token>
    // - x-api-key -> X-API-Key: <token>
    // Ajuste conforme sua API
    const API_AUTH = {
      mode: 'bearer',
      headerName: 'Authorization',
      prefix: 'Bearer '
    };

    function getAuthHeaders() {
      if (!API_TOKEN || API_TOKEN === 'token-nao-encontrado') return {};
      if (API_AUTH.mode === 'none') return {};
      if (API_AUTH.mode === 'x-api-key') {
        return { 'X-API-Key': API_TOKEN };
      }
      if (API_AUTH.mode === 'plain') {
        return { 'Authorization': API_TOKEN };
      }
      // default bearer
      return { [API_AUTH.headerName || 'Authorization']: `${API_AUTH.prefix || 'Bearer '}${API_TOKEN}` };
    }

    // Toggle para simular dados caso APIs falhem (mantém a página utilizável)
    const USE_FALLBACK_ON_ERROR = true;

    // Estado da aplicação
    const state = {
      centrosCusto: [],
      produtos: [],
      produtosLoaded: false,
      itens: [], // { idTemp, produtoId, produtoNome, quantidade }
      editMode: false
    };

    // Utilidades UI
    function showAlert(type, message) {
      const wrapper = document.createElement('div');
      wrapper.className = `alert alert-${type} alert-dismissible fade show`;
      wrapper.role = 'alert';
      wrapper.innerHTML = `\n        <div>${message}</div>\n        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>\n      `;
      document.getElementById('appAlerts').appendChild(wrapper);
    }

    function setLoading(selectEl, isLoading) {
      if (!selectEl) return;
      if (isLoading) {
        selectEl.innerHTML = '<option value="">Carregando...</option>';
        selectEl.disabled = true;
      } else {
        selectEl.disabled = false;
      }
    }

    // Overlay de carregamento
    function showLoading(message = 'Carregando...') {
      const el = document.getElementById('globalLoading');
      const txt = document.getElementById('globalLoadingText');
      if (!el) return;
      // Garante que o overlay fique no topo da pilha
      try { document.body.appendChild(el); } catch {}
      if (txt) txt.textContent = message;
      el.classList.remove('d-none');
      el.style.display = 'flex';
      el.style.visibility = 'visible';
      el.setAttribute('aria-hidden', 'false');
      // Evita rolagem enquanto carrega
      document.body.classList.add('overflow-hidden');
    }

    function hideLoading() {
      const el = document.getElementById('globalLoading');
      if (!el) return;
      el.classList.add('d-none');
      el.style.display = 'none';
      el.style.visibility = 'hidden';
      el.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('overflow-hidden');
    }

    // Helper para exibir overlay durante uma operação assíncrona
    async function withLoading(message, fn) {
      showLoading(message);
      // dá tempo do navegador pintar o overlay
      await new Promise(r => setTimeout(r, 30));
      try {
        return await fn();
      } finally {
        hideLoading();
      }
    }

    // Fetch helpers
    function buildUrl(base, params) {
      if (!params || !Object.keys(params).length) return base;
      const url = new URL(base, window.location.origin);
      Object.entries(params).forEach(([k, v]) => {
        if (v !== undefined && v !== null && v !== '') url.searchParams.set(k, String(v));
      });
      return url.toString();
    }

    async function fetchJson(url) {
      const resp = await fetch(url, { headers: { 'Accept': 'application/json', ...getAuthHeaders() } });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      return await resp.json();
    }

    // Busca todas as páginas de produtos quando o backend retorna Data.Paginas
    async function fetchAllProdutosPages(baseUrl, reqCfg, queryParams) {
      // Se for GET, retorna uma única chamada sem paginação por body
      if ((reqCfg.method || 'GET').toUpperCase() === 'GET') {
        return await requestJson(baseUrl, { method: 'GET', params: queryParams });
      }
      const firstBody = reqCfg.body && reqCfg.body.Pagina ? reqCfg.body : { ...reqCfg.body, Pagina: { Number: 0, Lenght: 100 } };
      const first = await requestJson(baseUrl, { method: reqCfg.method || 'POST', params: queryParams, body: firstBody });
      // Se não houver paginação estruturada, retorna direto
      const paginas = first && first.Data && Array.isArray(first.Data.Paginas) ? first.Data.Paginas : [];
      if (!paginas.length) return first;

      // Agrega itens de todas as páginas
      const allItens = Array.isArray(first?.Data?.Itens) ? [...first.Data.Itens] : [];
      const promises = [];
      for (const p of paginas) {
        const num = typeof p.Number === 'number' ? p.Number : parseInt(p.Number, 10);
        if (num === 0 || Number.isNaN(num)) continue; // já temos a página 0
        const body = { ...(reqCfg.body || {}), Pagina: { Number: num, Lenght: p.Lenght ?? firstBody.Pagina.Lenght } };
        promises.push(requestJson(baseUrl, { method: reqCfg.method || 'POST', params: queryParams, body }));
      }
      const pages = await Promise.all(promises);
      for (const pg of pages) {
        if (pg && pg.Data && Array.isArray(pg.Data.Itens)) allItens.push(...pg.Data.Itens);
      }
      return { Data: { Itens: allItens } };
    }

    async function requestJson(baseUrl, { method = 'GET', params = undefined, body = undefined, extraHeaders = {} } = {}) {
      const url = buildUrl(baseUrl, params);
      const options = {
        method,
        headers: {
          'Accept': 'application/json',
          ...getAuthHeaders(),
          ...extraHeaders
        }
      };
      if (method !== 'GET' && method !== 'HEAD') {
        options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';
        options.body = body != null ? (typeof body === 'string' ? body : JSON.stringify(body)) : undefined;
      }
      const resp = await fetch(url, options);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      // algumas APIs podem não retornar JSON em 204
      if (resp.status === 204) return null;
      return await resp.json();
    }

    // Carregar centros de custo
    async function loadCentrosCusto() {
      const select = document.getElementById('centroCusto');
      setLoading(select, true);
      try {
        const data = await fetchJson(API.centrosCustoUrl);
        state.centrosCusto = Array.isArray(data) ? data : [];
      } catch (e) {
        if (USE_FALLBACK_ON_ERROR) {
          state.centrosCusto = [
            { id: 'cc-1', nome: 'Administrativo' },
            { id: 'cc-2', nome: 'Operações' },
            { id: 'cc-3', nome: 'Tecnologia' }
          ];
          showAlert('warning', 'Falha ao buscar Centros de Custo na API. Usando dados temporários.');
        } else {
          showAlert('danger', 'Não foi possível carregar Centros de Custo.');
        }
      } finally {
        renderCentrosCusto();
        setLoading(select, false);
      }
    }

    function renderCentrosCusto() {
      const select = document.getElementById('centroCusto');
      select.innerHTML = '<option value="">Selecione...</option>' +
        state.centrosCusto.map(cc => `<option value="${cc.id}">${cc.nome}</option>`).join('');
    }

    // Normalização de produtos para diferentes formatos de API
    function normalizeProdutos(data) {
      if (!data) return [];

      // 1) Preferência explícita: Data.Itens (conforme JSON enviado)
      if (data && data.Data && Array.isArray(data.Data.Itens)) {
        return data.Data.Itens.map(p => {
          const rawId = p.Id ?? p.ID ?? p.Codigo ?? p.codigo;
          const id = typeof rawId === 'number' ? String(rawId) : rawId;
          const nome = p.Nome ?? p.NomeWeb ?? p.Descricao ?? p.descricao ?? p.name;
          const codigo = p.Codigo ?? p.codigo ?? null;
          return { id, nome: String(nome ?? id ?? ''), codigo };
        }).filter(p => p.id && p.nome);
      }

      // 2) Outras variações comuns: Itens na raiz, ou chaves conhecidas
      const candidateArrays = [];
      const tryPush = (arr) => { if (Array.isArray(arr) && arr.length) candidateArrays.push(arr); };
      tryPush(data.Itens);
      tryPush(data.items);
      tryPush(data.data);
      tryPush(data.result);
      tryPush(data.produtos);
      tryPush(data.lista);
      tryPush(data.rows);

      // 3) Busca profunda: prioriza arrays com itens que tenham aparência de produto (Nome/Id/Codigo)
      function collectArraysDeep(obj, depth = 0) {
        if (!obj || depth > 5) return;
        if (Array.isArray(obj)) { tryPush(obj); return; }
        if (typeof obj !== 'object') return;
        for (const v of Object.values(obj)) collectArraysDeep(v, depth + 1);
      }
      collectArraysDeep(data);

      // Heurística: escolher o primeiro array que possua objetos com alguma das chaves típicas
      const looksLikeProducts = (arr) => arr.some(x => x && typeof x === 'object' && (
        'Nome' in x || 'nome' in x || 'Descricao' in x || 'descricao' in x || 'Id' in x || 'ID' in x || 'Codigo' in x || 'codigo' in x
      ));
      const arr = candidateArrays.find(looksLikeProducts) || candidateArrays[0] || [];

      return arr
        .filter(x => x && typeof x === 'object')
        .map(p => {
          const rawId = p.Id ?? p.ID ?? p.Codigo ?? p.codigo ?? p.productId ?? p.idProduto ?? p.CodProduto ?? p.sku;
          const id = typeof rawId === 'number' ? String(rawId) : rawId;
          const nome = p.Nome ?? p.nome ?? p.NomeWeb ?? p.Descricao ?? p.descricao ?? p.descricaoProduto ?? p.name ?? p.product_name ?? p.titulo;
          const codigo = p.Codigo ?? p.codigo ?? null;
          return { id, nome: String(nome ?? id ?? ''), codigo };
        })
        .filter(p => p.id && p.nome);
    }

    // Carregar produtos
    async function loadProdutos() {
      const select = document.getElementById('produto');
      setLoading(select, true);
      try {
        const reqCfg = API_REQUEST.produtos || { method: 'GET' };
        // Log de auth (sem expor token)
        try {
          const hasToken = !!API_TOKEN && API_TOKEN !== 'token-nao-encontrado';
          console.log('[Produtos] Auth mode:', API_AUTH.mode, '| Token presente:', hasToken);
        } catch {}

        // Carrega apenas a primeira página para evitar muitas requisições paralelas
        const data = await requestJson(API.produtosUrl, { method: reqCfg.method || 'POST', params: API_PARAMS.produtos, body: reqCfg.body });
        window.__lastProdutosResponse = data; // facilitar inspeção no console
        console.log('Resposta Produtos (bruta):', data);
        // Atalho: se vier no formato esperado Data.Itens, mapeia diretamente
        if (data && data.Data && Array.isArray(data.Data.Itens) && data.Data.Itens.length) {
          const mapped = data.Data.Itens
            .filter(p => p && (p.Id != null || p.Codigo != null || p.ID != null))
            .map(p => {
              const rawId = p.Id ?? p.ID ?? p.Codigo ?? p.codigo;
              const id = typeof rawId === 'number' ? String(rawId) : String(rawId);
              const nome = p.Nome ?? p.NomeWeb ?? p.Descricao ?? p.descricao ?? id;
              const codigo = p.Codigo ?? p.codigo ?? null;
              return { id, nome: String(nome), codigo };
            })
            .filter(p => p.id && p.nome);
          state.produtos = mapped;
          state.produtosLoaded = true;
          console.log('Produtos mapeados via Data.Itens:', { count: mapped.length, sample: mapped.slice(0,3) });
          // Renderiza imediatamente e garante visibilidade do select
          try {
            const selectEl = document.getElementById('produto');
            if (selectEl) {
              // Preenche diretamente as opções para evitar qualquer race
              selectEl.innerHTML = '<option value="">Selecione...</option>' +
                mapped.map(p => `<option value="${p.id}">${p.nome}</option>`).join('');
              selectEl.classList.remove('d-none');
            }
            // Também realiza o render padrão
            renderProdutos();
            console.log('Opções no select:', document.querySelectorAll('#produto option').length);
          } catch {}
          showAlert('success', `Produtos carregados: ${mapped.length}`);
          return;
        }
        const norm = normalizeProdutos(data);
        console.log('Produtos normalizados:', { count: norm.length, sample: norm.slice(0, 3) });
        if (!norm.length) {
          showAlert('warning', 'A API de Produtos respondeu sem itens. Tentando fallback GET...');
          try {
            const topKeys = data && typeof data === 'object' ? Object.keys(data).slice(0, 10) : [];
            const innerKeys = data && data.Data && typeof data.Data === 'object' ? Object.keys(data.Data).slice(0, 10) : [];
            showAlert('info', `Chaves recebidas: ${topKeys.join(', ')}${innerKeys.length ? ' | Data: ' + innerKeys.join(', ') : ''}`);
          } catch {}
          // Fallback: tentar GET simples
          try {
            const dataGet = await requestJson(API.produtosUrl, { method: 'GET', params: API_PARAMS.produtos });
            const normGet = normalizeProdutos(dataGet);
            if (!normGet.length) {
              showAlert('warning', 'Fallback GET também não retornou itens. Verifique formato/resposta da API.');
            }
            state.produtos = normGet;
            state.produtosLoaded = state.produtos.length > 0;
          } catch (e2) {
            console.error('Erro no fallback GET de Produtos:', e2);
            throw e2; // delega para o catch externo para aplicar fallback se habilitado
          }
        } else {
          state.produtos = norm;
          state.produtosLoaded = state.produtos.length > 0;
          showAlert('success', `Produtos carregados: ${norm.length}`);
        }
      } catch (e) {
        const msg = String(e && e.message || '');
        console.error('Erro ao carregar Produtos:', e);
        // Em erros de autenticação, não usar fallback para não mascarar o problema
        if (msg.includes('HTTP 401') || msg.includes('HTTP 403')) {
          showAlert('danger', 'Falha de autenticação para Produtos (401/403). Confira o token e o formato do header.');
          if (!state.produtosLoaded) state.produtos = [];
        } else if (msg.includes('HTTP 405')) {
          showAlert('danger', 'Endpoint de Produtos retornou 405 (Method Not Allowed). Tente mudar o método em API_REQUEST.produtos (GET/POST).');
          if (!state.produtosLoaded) state.produtos = [];
        } else {
          const match = msg.match(/HTTP\s+(\d{3})/);
          const status = match ? match[1] : 'erro desconhecido';
          showAlert('danger', `Não foi possível carregar Produtos (status: ${status}).`);
        }
      } finally {
        // Só re-renderiza automaticamente se houver produtos no estado,
        // para não apagar opções já preenchidas em casos de corrida
        if (Array.isArray(state.produtos) && state.produtos.length > 0) {
          renderProdutos();
        }
        setLoading(select, false);
        try {
          if (Array.isArray(state.produtos) && state.produtos.length > 0) {
            select.classList.remove('d-none');
          }
        } catch {}
      }
    }

    function renderProdutos() {
      const select = document.getElementById('produto');
      try { console.log('[renderProdutos] state.produtos.length:', Array.isArray(state.produtos) ? state.produtos.length : 'n/a'); } catch {}
      // Se por algum motivo o estado estiver vazio mas a última resposta tiver itens, mapeia aqui
      try {
        if ((!Array.isArray(state.produtos) || state.produtos.length === 0)
            && window.__lastProdutosResponse?.Data?.Itens?.length) {
          const itens = window.__lastProdutosResponse.Data.Itens;
          const mapped = itens
            .filter(p => p && (p.Id != null || p.Codigo != null || p.ID != null))
            .map(p => {
              const rawId = p.Id ?? p.ID ?? p.Codigo ?? p.codigo;
              const id = typeof rawId === 'number' ? String(rawId) : String(rawId);
              const nome = p.Nome ?? p.NomeWeb ?? p.Descricao ?? p.descricao ?? id;
              const codigo = p.Codigo ?? p.codigo ?? null;
              return { id, nome: String(nome), codigo };
            })
            .filter(p => p.id && p.nome);
          if (mapped.length) {
            console.log('[renderProdutos] repovoando a partir de __lastProdutosResponse:', mapped.length);
            state.produtos = mapped;
          }
        }
      } catch {}
      // Evita limpar opções válidas quando state.produtos estiver vazio
      const hadOptions = select.querySelectorAll('option').length > 1;
      if ((!Array.isArray(state.produtos) || state.produtos.length === 0) && hadOptions) {
        console.log('[renderProdutos] preservando opções existentes (estado vazio)');
        return;
      }
      select.innerHTML = '<option value="">Selecione...</option>' +
        state.produtos.map(p => `<option value="${p.id}">${p.nome}</option>`).join('');
      try {
        const optCount = select.querySelectorAll('option').length;
        console.log('[renderProdutos] options:', optCount);
        if (state.produtos.length > 0 && select.selectedIndex === 0) {
          select.selectedIndex = 1; // auto-seleciona o primeiro produto
          select.dispatchEvent(new Event('change'));
        }
      } catch {}
    }

    // Manipulação de itens
    function addItem() {
      const produtoId = document.getElementById('produto').value;
      const quantidade = parseInt(document.getElementById('quantidade').value, 10);
      if (!produtoId) return showAlert('warning', 'Selecione um produto.');
      if (!quantidade || quantidade <= 0) return showAlert('warning', 'Informe uma quantidade válida.');

      const produto = state.produtos.find(p => String(p.id) === String(produtoId));
      if (!produto) return showAlert('danger', 'Produto selecionado é inválido.');

      // Se já existir produto na lista, soma quantidade
      const existente = state.itens.find(i => String(i.produtoId) === String(produtoId));
      if (existente) {
        existente.quantidade += quantidade;
      } else {
        state.itens.push({ idTemp: crypto.randomUUID(), produtoId, produtoNome: produto.nome, quantidade });
      }

      renderItens();
      clearItemForm();
    }

    function clearItemForm() {
      document.getElementById('produto').value = '';
      document.getElementById('quantidade').value = '';
      document.getElementById('produto').focus();
    }

    function removeItem(idTemp) {
      state.itens = state.itens.filter(i => i.idTemp !== idTemp);
      renderItens();
    }

    function updateQuantidade(idTemp, novaQtd) {
      const item = state.itens.find(i => i.idTemp === idTemp);
      if (!item) return;
      const q = parseInt(novaQtd, 10);
      if (!q || q <= 0) return; // simples validação inline
      item.quantidade = q;
    }

    function renderItens() {
      const tbody = document.getElementById('tbodyItens');
      if (!state.itens.length) {
        tbody.innerHTML = '<tr><td colspan="3" class="text-center text-muted">Nenhum item adicionado.</td></tr>';
        return;
      }

      tbody.innerHTML = state.itens.map(item => {
        const qtdCell = state.editMode
          ? `<input type="number" min="1" step="1" class="form-control form-control-sm" value="${item.quantidade}" data-id="${item.idTemp}" />`
          : `<span>${item.quantidade}</span>`;

        const opcoes = state.editMode
          ? `<button class="btn btn-sm btn-outline-danger" data-action="remover" data-id="${item.idTemp}">Remover</button>`
          : `
            <div class="btn-group btn-group-sm" role="group">
              <button class="btn btn-outline-secondary" data-action="editar1" data-id="${item.idTemp}">Editar</button>
              <button class="btn btn-outline-danger" data-action="remover" data-id="${item.idTemp}">Remover</button>
            </div>`;

        return `
          <tr>
            <td>${item.produtoNome}</td>
            <td style="max-width:140px">${qtdCell}</td>
            <td class="no-print">${opcoes}</td>
          </tr>`;
      }).join('');

      // Eventos de inputs em modo edição
      if (state.editMode) {
        tbody.querySelectorAll('input[type="number"]').forEach(inp => {
          inp.addEventListener('change', (e) => {
            updateQuantidade(e.target.dataset.id, e.target.value);
          });
        });
      }

      // Eventos de botões por linha
      tbody.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = e.currentTarget.dataset.action;
          const id = e.currentTarget.dataset.id;
          if (action === 'remover') removeItem(id);
          if (action === 'editar1') {
            // Atalho: trocar para modo edição e focar no input da linha
            state.editMode = true;
            renderItens();
            const inp = tbody.querySelector(`input[data-id="${id}"]`);
            if (inp) inp.focus();
            updateEditButton();
          }
        });
      });
    }

    // Salvar solicitação
    async function salvarSolicitacao() {
      const solicitante = document.getElementById('solicitante').value.trim();
      const centroCustoId = document.getElementById('centroCusto').value;
      const narrativa = document.getElementById('narrativa').value.trim();

      if (!solicitante) return showAlert('warning', 'Informe o nome do solicitante.');
      if (!centroCustoId) return showAlert('warning', 'Selecione um Centro de Custo.');
      if (!state.itens.length) return showAlert('warning', 'Adicione pelo menos um item.');

      const payload = {
        solicitante,
        centroCustoId,
        narrativa,
        itens: state.itens.map(i => ({ produtoId: i.produtoId, quantidade: i.quantidade }))
      };

      // desabilita botão enquanto salva
      const btnSalvar = document.getElementById('btnSalvar');
      btnSalvar.disabled = true;
      btnSalvar.innerText = 'Salvando...';

      try {
        showLoading('Salvando solicitação...');
        const resp = await fetch(API.salvarSolicitacaoUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            ...getAuthHeaders()
          },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) throw new Error(`Falha ao salvar: HTTP ${resp.status}`);
        const data = await resp.json().catch(() => ({}));
        showAlert('success', 'Solicitação salva com sucesso.');
        // opcional: exibir número/ID retornado
        if (data && (data.id || data.numero)) {
          showAlert('info', `Protocolo: ${data.id || data.numero}`);
        }
      } catch (e) {
        if (USE_FALLBACK_ON_ERROR) {
          showAlert('warning', 'Não foi possível salvar na API. Simulando salvamento local.');
          console.log('Payload (simulado):', payload);
        } else {
          showAlert('danger', 'Erro ao salvar solicitação. Tente novamente.');
        }
      } finally {
        btnSalvar.disabled = false;
        btnSalvar.innerText = 'Salvar solicitação';
        hideLoading();
      }
    }

    // Modo edição geral
    function toggleEditMode() {
      state.editMode = !state.editMode;
      updateEditButton();
      renderItens();
    }

    function updateEditButton() {
      const btn = document.getElementById('btnToggleEdit');
      btn.textContent = state.editMode ? 'Concluir edição' : 'Editar todos';
    }

    // Eventos principais
    function setupEvents() {
      document.getElementById('btnAdicionar').addEventListener('click', (e) => {
        e.preventDefault();
        addItem();
      });

      document.getElementById('btnLimpar').addEventListener('click', (e) => {
        e.preventDefault();
        clearItemForm();
      });

      document.getElementById('btnCarregar').addEventListener('click', async (e) => {
        e.preventDefault();
        await withLoading('Carregando produtos...', async () => {
          await loadProdutos();
        });
      });

      document.getElementById('btnSalvar').addEventListener('click', (e) => {
        e.preventDefault();
        salvarSolicitacao();
      });

      document.getElementById('btnImprimir').addEventListener('click', () => window.print());
      document.getElementById('btnToggleEdit').addEventListener('click', toggleEditMode);

      // Modal de produtos
      const btnAbrir = document.getElementById('btnAbrirModalProdutos');
      const modalEl = document.getElementById('modalProdutos');
      const searchEl = document.getElementById('produtoSearch');
      const tbodyModal = document.getElementById('tbodyModalProdutos');
      const btnAddSel = document.getElementById('btnAddSelecionados');
      const btnCarregar = document.getElementById('btnCarregarProdutos');
      const lblInfo = document.getElementById('lblModalProdutosInfo');

      const modalState = { selected: new Map(), filtered: [], limit: 100 };

      function renderModalProdutos() {
        const term = (searchEl.value || '').toLowerCase().trim();
        const base = Array.isArray(state.produtos) ? state.produtos : [];
        const filtered = term
          ? base.filter(p => `${p.codigo ?? ''}`.toLowerCase().includes(term) || (p.nome || '').toLowerCase().includes(term))
          : base;
        const total = filtered.length;
        modalState.filtered = filtered.slice(0, modalState.limit);
        if (lblInfo) {
          const shown = modalState.filtered.length;
          lblInfo.textContent = `Mostrando ${shown}${shown < total ? ` de ${total}` : ''} resultado(s)`;
        }
        tbodyModal.innerHTML = modalState.filtered.map(p => {
          const checked = modalState.selected.has(p.id) ? 'checked' : '';
          const qtd = modalState.selected.get(p.id)?.quantidade ?? 1;
          return `
            <tr>
              <td><input type="checkbox" class="form-check-input" data-role="sel" data-id="${p.id}"></td>
              <td>${p.codigo ?? p.id}</td>
              <td>${p.nome}</td>
              <td style="max-width:120px">
                <input type="number" min="1" step="1" class="form-control form-control-sm" data-role="qtd" data-id="${p.id}" value="${qtd}" ${checked ? '' : ''}>
              </td>
            </tr>`;
        }).join('');

        // Apply checked states after render
        tbodyModal.querySelectorAll('input[data-role="sel"]').forEach(cb => {
          const id = cb.dataset.id;
          cb.checked = modalState.selected.has(id);
        });

        // Events
        tbodyModal.querySelectorAll('input[data-role="sel"]').forEach(cb => {
          cb.addEventListener('change', (e) => {
            const id = e.target.dataset.id;
            const qtdInp = tbodyModal.querySelector(`input[data-role="qtd"][data-id="${id}"]`);
            const qtdVal = parseInt(qtdInp?.value || '1', 10) || 1;
            if (e.target.checked) {
              modalState.selected.set(id, { quantidade: qtdVal });
            } else {
              modalState.selected.delete(id);
            }
          });
        });

        tbodyModal.querySelectorAll('input[data-role="qtd"]').forEach(inp => {
          inp.addEventListener('change', (e) => {
            const id = e.target.dataset.id;
            const q = parseInt(e.target.value || '1', 10) || 1;
            if (modalState.selected.has(id)) {
              modalState.selected.set(id, { quantidade: q });
            }
          });
        });
      }

      function openProductModal() {
        modalState.selected.clear();
        searchEl.value = '';
        modalState.limit = 100;
        renderModalProdutos();
        const modal = new bootstrap.Modal(modalEl);
        modal.show();
        // Guardar a ref para fechar ao confirmar
        modalEl._instance = modal;
      }

      if (btnAbrir) btnAbrir.addEventListener('click', openProductModal);
      if (searchEl) searchEl.addEventListener('input', renderModalProdutos);
      if (btnCarregar) btnCarregar.addEventListener('click', async () => {
        btnCarregar.disabled = true;
        const originalText = btnCarregar.textContent;
        btnCarregar.textContent = 'Carregando...';
        showLoading('Carregando todos os produtos...');
        // Garante que o overlay renderize antes da operação pesada
        await new Promise(r => setTimeout(r, 50));
        try {
          const baseCfg = API_REQUEST.produtos || { method: 'POST', body: {} };
          const cfg = JSON.parse(JSON.stringify(baseCfg));
          if (!cfg.body) cfg.body = {};
          // Tenta carregar com página maior e todas as páginas
          cfg.body.Pagina = { Number: 0, Lenght: 1000 };
          const data = await fetchAllProdutosPages(API.produtosUrl, cfg, API_PARAMS.produtos);
          const norm = normalizeProdutos(data);
          if (!norm.length) {
            showAlert('warning', 'Nenhum produto retornado ao carregar todos.');
          }
          state.produtos = norm;
          // Remover limite após carregar todos
          modalState.limit = Number.MAX_SAFE_INTEGER;
          renderModalProdutos();
        } catch (e) {
          console.error('Falha ao carregar todos os produtos:', e);
          showAlert('danger', 'Falha ao carregar todos os produtos.');
        } finally {
          btnCarregar.disabled = false;
          btnCarregar.textContent = originalText;
          hideLoading();
        }
      });
      if (btnAddSel) btnAddSel.addEventListener('click', () => {
        if (!modalState.selected.size) {
          showAlert('warning', 'Selecione ao menos um produto.');
          return;
        }
        // Adiciona cada produto selecionado com a quantidade escolhida
        for (const [id, { quantidade }] of modalState.selected.entries()) {
          const produto = state.produtos.find(p => String(p.id) === String(id));
          if (!produto) continue;
          const existente = state.itens.find(i => String(i.produtoId) === String(id));
          if (existente) {
            existente.quantidade += quantidade;
          } else {
            state.itens.push({ idTemp: crypto.randomUUID(), produtoId: id, produtoNome: produto.nome, quantidade });
          }
        }
        renderItens();
        // Fecha modal
        if (modalEl._instance) modalEl._instance.hide();
      });
    }

    // Inicialização
    async function init() {
      setupEvents();
      renderItens();
      // Alerta imediato se o token não for encontrado
      if (!API_TOKEN || API_TOKEN === 'token-nao-encontrado') {
        showAlert('danger', 'Token de autenticação não encontrado. Produtos podem não carregar (401/403).');
      }
      await withLoading('Carregando dados...', async () => {
        await Promise.all([loadCentrosCusto(), loadProdutos()]);
      });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
